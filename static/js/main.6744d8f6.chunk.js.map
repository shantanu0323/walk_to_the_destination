{"version":3,"sources":["logo.svg","algorithms/mazeGeneratingAlgorithms/recursive_division.js","components/NavBar/NavItem/navitem.jsx","helper/position.js","algorithms/mazeGeneratingAlgorithms/binary_tree.js","algorithms/mazeGeneratingAlgorithms/dfs.js","algorithms/mazeGeneratingAlgorithms/random.js","components/NavBar/navbar.jsx","components/Node/node_state.jsx","components/Node/node.jsx","components/Legend/legend.jsx","components/Grid/grid.jsx","components/Insights/insights.jsx","components/Copyright/copyright.jsx","algorithms/dijkstra.js","helper/initialise.js","components/Loader/loader.jsx","algorithms/a_star.js","algorithms/greedy.js","algorithms/bfs.js","algorithms/dfs.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","orientation","NavItem","state","description","getSelectedOptionDescription","props","selectedOption","options","handleHover","option","setState","this","onChanged","hasDescription","undefined","optionNamesContainerWidth","selectedOptionObject","getSelectedOption","className","style","width","map","key","id","textAlign","onMouseEnter","onMouseLeave","onClick","speed","name","left","filter","Component","Position","x","y","isEqual","a","b","JSON","stringify","getNeighbours","position","rows","columns","step","neighbours","push","isOnEdge","generateBinaryTreeMaze","source","target","walls","i","j","Math","round","random","sourceNeighbours","targetNeighbours","wall","some","node","visitedNodes","findNextNode","currNode","visitedNode","forEach","neighbour","connectAndMarkAsVisited","floor","length","generateDFSMaze","generateRecursiveDivisionMaze","window","buildWalls","startRow","endRow","startColumn","endColumn","wallIndex","pathIndex","index","generateRandomMaze","generateRandomWalls","sort","NavBar","algorithms","href","title","mazes","speeds","selectedMazeId","constructMaze","setTimeout","nodeDom","document","querySelector","classList","remove","add","stopLoading","onMazeCreated","getSelectedMazeFunction","mazeId","setMazeId","generateMaze","resetMesh","startLoading","console","log","wallsInOrder","alert","selectedAlgorithmId","algorithm","maze","selectedSpeedId","onAlgorithmChanged","onSpeedChanged","startWalking","clearPath","destructWalls","Fragment","src","logo","height","alt","showAlgorithmOptionsContainer","getSelectedAlgorithm","showMazeOptionsContainer","getSelectedMaze","showSpeedOptionsContainer","getSelectedSpeed","NodeState","NODE_UNVISITED","NODE_VISITED","NODE_IS_WALL","NODE_IS_SOURCE","NODE_IS_TARGET","NODE_FALLS_IN_PATH","NODE_IS_VISITING","Node","nodeState","onMouseDown","onMouseUp","getNodeStateClass","data-x","data-y","classes","Legend","disabled","Grid","isMousePressed","movingSource","movingTarget","toggleWall","setNodeAsSource","setNodeAsTarget","paddingX","innerWidth","paddingY","innerHeight","nodes","decideNodeState","handleMouseDown","handleMouseUp","handleMouseEnter","handleMouseLeave","paddingTop","paddingRight","paddingBottom","paddingLeft","Insights","insights","Copyright","distance","Infinity","mesh","unvisitedNodes","getNonWallNeighbours","neighbourPositions","getPreviousNodeInPath","prevNode","min","performDijkstra","row","initialiseMesh","visitedNodesObjects","minDist","getVisitedNodes","pathObjects","path","unshift","getNodesInPath","resetSourceAndTarget","sourceDom","targetDom","Loader","loading","parent","f","g","h","openList","closedList","abs","performAstar","sourceNode","shift","getTraversableNeighbours","found","performGreedy","queue","parents","getKey","getNonWallUnvisitedNeighbours","performBFS","runBFS","getPath","targetFound","runDFS","performDFS","App","setAlgorithmId","setSpeedId","putNodeInPath","contains","getSelectedAlgorithmFunction","k","updateMaze","s","createElement","type","async","crossOrigin","body","appendChild","gridHeight","gridWidth","parseInt","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.6744d8f6.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import Position, { isEqual, getNeighbours } from \"../../helper/position\";\n\nconst walls = [];\nconst visitedNodes = [];\nconst isOnEdge = (position, rows, columns) => {\n    return (\n        position.x === 1 ||\n        position.x === rows ||\n        position.y === 1 ||\n        position.y === columns\n    );\n};\n\nlet orientation;\nconst buildWalls = (startRow, endRow, startColumn, endColumn) => {\n    orientation = !orientation;\n    if (orientation) {\n        if (startColumn >= endColumn) return;\n        const wallIndex =\n            2 *\n                (Math.floor((Math.random() * (endColumn - startColumn)) / 2) +\n                    startColumn / 2) +\n            1;\n        const pathIndex =\n            Math.floor(Math.random() * (endRow - startRow + 1)) + startRow;\n        getNeighbours(\n            new Position(pathIndex, wallIndex),\n            window.rows,\n            window.columns\n        )\n            .filter((node) => node.x === pathIndex)\n            .map((node) => visitedNodes.push(node));\n        for (let index = startRow; index <= endRow; index++) {\n            if (\n                index === pathIndex ||\n                visitedNodes.some((node) =>\n                    isEqual(node, new Position(index, wallIndex))\n                )\n            )\n                continue;\n            walls.push(new Position(index, wallIndex));\n        }\n        buildWalls(startRow, endRow, startColumn, wallIndex - 1);\n        buildWalls(startRow, endRow, wallIndex + 1, endColumn);\n    } else {\n        if (startRow >= endRow) return;\n        const wallIndex =\n            2 *\n                (Math.floor((Math.random() * (endRow - startRow)) / 2) +\n                    startRow / 2) +\n            1;\n        const pathIndex =\n            Math.floor(Math.random() * (endColumn - startColumn + 1)) +\n            startColumn;\n        getNeighbours(\n            new Position(wallIndex, pathIndex),\n            window.rows,\n            window.columns\n        )\n            .filter((node) => node.y === pathIndex)\n            .map((node) => visitedNodes.push(node));\n        for (let index = startColumn; index <= endColumn; index++) {\n            if (\n                index === pathIndex ||\n                visitedNodes.some((node) =>\n                    isEqual(node, new Position(wallIndex, index))\n                )\n            )\n                continue;\n            walls.push(new Position(wallIndex, index));\n        }\n        buildWalls(startRow, wallIndex - 1, startColumn, endColumn);\n        buildWalls(wallIndex + 1, endRow, startColumn, endColumn);\n    }\n};\n\nconst generateRecursiveDivisionMaze = (rows, columns, source, target) => {\n    walls.length = 0;\n    visitedNodes.length = 0;\n    window.rows = rows;\n    window.columns = columns;\n    orientation = Math.random() >= 0.5;\n    for (let i = 1; i <= rows; i++) {\n        walls.push(new Position(i, 1));\n        walls.push(new Position(i, columns));\n    }\n\n    for (let j = 2; j < columns; j++) {\n        walls.push(new Position(1, j));\n        walls.push(new Position(rows, j));\n    }\n\n    buildWalls(2, rows - 1, 2, columns - 1);\n\n    const sourceNeighbours = isOnEdge(source)\n        ? getNeighbours(source, rows, columns)\n        : [];\n    const targetNeighbours = isOnEdge(target)\n        ? getNeighbours(target, rows, columns)\n        : [];\n    return walls.filter(\n        (wall) =>\n            !isEqual(wall, source) &&\n            !isEqual(wall, target) &&\n            (wall.y !== columns - 1 || wall.x === 1 || wall.x === rows) &&\n            !sourceNeighbours.some((node) => isEqual(node, wall)) &&\n            !targetNeighbours.some((node) => isEqual(node, wall))\n    );\n};\n\nexport default generateRecursiveDivisionMaze;\n","import React, { Component } from \"react\";\n\nclass NavItem extends Component {\n    state = {\n        description: this.getSelectedOptionDescription(\n            this.props.selectedOption,\n            this.props.options\n        ),\n    };\n\n    handleHover = (option) => {\n        this.setState({ description: option.description });\n    };\n\n    render() {\n        const { options, selectedOption, onChanged } = this.props;\n        const hasDescription =\n            options[0].description === undefined ? false : true;\n        const optionNamesContainerWidth = hasDescription ? \"30%\" : \"100%\";\n        let selectedOptionObject = this.getSelectedOption(\n            selectedOption,\n            options\n        );\n\n        return (\n            <div className=\"options-container\">\n                <div\n                    className=\"option-names-container\"\n                    style={{ width: optionNamesContainerWidth }}\n                >\n                    {options.map((option) => (\n                        <button\n                            key={option.id}\n                            style={{\n                                textAlign: hasDescription ? \"right\" : \"center\",\n                            }}\n                            className={\n                                option.id === selectedOption ? \"active\" : \"\"\n                            }\n                            onMouseEnter={() => this.handleHover(option)}\n                            onMouseLeave={() =>\n                                this.handleHover(selectedOptionObject)\n                            }\n                            onClick={() =>\n                                onChanged(\n                                    option.id,\n                                    option.speed === undefined\n                                        ? null\n                                        : option.speed\n                                )\n                            }\n                        >\n                            {option.name}\n                        </button>\n                    ))}\n                </div>\n                {hasDescription ? (\n                    <div\n                        className=\"option-description-container\"\n                        style={{\n                            width: \"60%\",\n                            left: optionNamesContainerWidth,\n                        }}\n                    >\n                        {this.state.description}\n                    </div>\n                ) : null}\n            </div>\n        );\n    }\n\n    getSelectedOption(selectedOption, options) {\n        const option = options.filter((option) => option.id === selectedOption);\n        return option[0];\n    }\n    getSelectedOptionDescription(selectedOption, options) {\n        const option = this.getSelectedOption(selectedOption, options);\n        return option === undefined ? null : option.description;\n    }\n}\n\nexport default NavItem;\n","class Position {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nconst isEqual = (a, b) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\n\nconst getNeighbours = (position, rows, columns, step = 1) => {\n    const neighbours = [];\n    if (\n        position.x >= 1 &&\n        position.x <= rows &&\n        position.y >= 1 &&\n        position.y + step <= columns\n    ) {\n        neighbours.push(new Position(position.x, position.y + step));\n    }\n    if (\n        position.x >= 1 &&\n        position.x + step <= rows &&\n        position.y >= 1 &&\n        position.y <= columns\n    ) {\n        neighbours.push(new Position(position.x + step, position.y));\n    }\n    if (\n        position.x >= 1 &&\n        position.x <= rows &&\n        position.y - step >= 1 &&\n        position.y <= columns\n    ) {\n        neighbours.push(new Position(position.x, position.y - step));\n    }\n    if (\n        position.x - step >= 1 &&\n        position.x <= rows &&\n        position.y >= 1 &&\n        position.y <= columns\n    ) {\n        neighbours.push(new Position(position.x - step, position.y));\n    }\n    return neighbours;\n};\n\nexport { isEqual, getNeighbours };\nexport default Position;\n","import Position, { isEqual, getNeighbours } from \"../../helper/position\";\n\nconst isOnEdge = (position, rows, columns) => {\n    return (\n        position.x === 1 ||\n        position.x === rows ||\n        position.y === 1 ||\n        position.y === columns\n    );\n};\n\nconst generateBinaryTreeMaze = (rows, columns, source, target) => {\n    const walls = [];\n    for (let i = 1; i <= rows; i++) {\n        walls.push(new Position(i, 1));\n        walls.push(new Position(i, columns));\n    }\n\n    for (let j = 2; j < columns; j++) {\n        walls.push(new Position(1, j));\n        walls.push(new Position(rows, j));\n    }\n\n    for (let i = 3; i < rows - 1; i += 2) {\n        for (let j = 3; j < columns - 1; j += 2) {\n            walls.push(new Position(i, j));\n            if (Math.round(Math.random())) {\n                walls.push(new Position(i - 1, j));\n            } else {\n                walls.push(new Position(i, j - 1));\n            }\n        }\n    }\n    const sourceNeighbours = isOnEdge(source)\n        ? getNeighbours(source, rows, columns)\n        : [];\n    const targetNeighbours = isOnEdge(target)\n        ? getNeighbours(target, rows, columns)\n        : [];\n    return walls.filter(\n        (wall) =>\n            !isEqual(wall, source) &&\n            !isEqual(wall, target) &&\n            (wall.y !== columns - 1 || wall.x === 1 || wall.x === rows) &&\n            !sourceNeighbours.some((node) => isEqual(node, wall)) &&\n            !targetNeighbours.some((node) => isEqual(node, wall))\n    );\n};\n\nexport default generateBinaryTreeMaze;\n","import Position, { isEqual, getNeighbours } from \"../../helper/position\";\n\nconst walls = [];\nconst visitedNodes = [];\n\nconst isOnEdge = (position, rows, columns) => {\n    return (\n        position.x === 1 ||\n        position.x === rows ||\n        position.y === 1 ||\n        position.y === columns\n    );\n};\n\nconst connectAndMarkAsVisited = (node, neighbours, rows, columns) => {\n    neighbours.forEach((neighbour) => {\n        const position = new Position(node.x, node.y);\n        if (neighbour.x === node.x) {\n            if (neighbour.y > node.y) position.y++;\n            else position.y--;\n        } else {\n            if (neighbour.x > node.x) position.x++;\n            else position.x--;\n        }\n        visitedNodes.push(neighbour);\n        walls.push(position);\n    });\n};\n\nconst findNextNode = (currNode, rows, columns) => {\n    walls.push(currNode);\n    let neighbours = getNeighbours(currNode, rows, columns, 2).filter(\n        (node) => {\n            return (\n                !walls.some((wall) => isEqual(wall, node)) &&\n                !visitedNodes.some((visitedNode) => isEqual(visitedNode, node))\n            );\n        }\n    );\n    connectAndMarkAsVisited(currNode, neighbours, rows, columns);\n    while (neighbours.length > 0) {\n        const currNode =\n            neighbours[Math.floor(Math.random() * neighbours.length)];\n        findNextNode(currNode, rows, columns);\n        neighbours = neighbours.filter((node) => !isEqual(node, currNode));\n    }\n};\n\nconst generateDFSMaze = (rows, columns, source, target) => {\n    for (let i = 1; i <= rows; i++) {\n        walls.push(new Position(i, 1));\n        walls.push(new Position(i, columns));\n    }\n\n    for (let j = 2; j < columns; j++) {\n        walls.push(new Position(1, j));\n        walls.push(new Position(rows, j));\n    }\n\n    findNextNode(new Position(3, 3), rows, columns);\n\n    const sourceNeighbours = isOnEdge(source)\n        ? getNeighbours(source, rows, columns)\n        : [];\n    const targetNeighbours = isOnEdge(target)\n        ? getNeighbours(target, rows, columns)\n        : [];\n    return walls.filter(\n        (wall) =>\n            !isEqual(wall, source) &&\n            !isEqual(wall, target) &&\n            (wall.y !== columns - 1 || wall.x === 1 || wall.x === rows) &&\n            !sourceNeighbours.some((node) => isEqual(node, wall)) &&\n            !targetNeighbours.some((node) => isEqual(node, wall))\n    );\n};\n\nexport default generateDFSMaze;\n","import Position, { isEqual, getNeighbours } from \"../../helper/position\";\n\nconst walls = [];\n\nconst isOnEdge = (position, rows, columns) => {\n    return (\n        position.x === 1 ||\n        position.x === rows ||\n        position.y === 1 ||\n        position.y === columns\n    );\n};\n\nconst generateRandomWalls = (rows, columns) => {\n    for (let i = 3; i < rows - 1; i++) {\n        for (let j = 3; j < columns - 1; j++) {\n            if (Math.random() >= 0.8) walls.push(new Position(i, j));\n        }\n    }\n};\n\nconst generateRandomMaze = (rows, columns, source, target) => {\n    for (let i = 1; i <= rows; i++) {\n        walls.push(new Position(i, 1));\n        walls.push(new Position(i, columns));\n    }\n\n    for (let j = 2; j < columns; j++) {\n        walls.push(new Position(1, j));\n        walls.push(new Position(rows, j));\n    }\n\n    generateRandomWalls(rows, columns);\n    walls.sort(function () {\n        return 0.5 - Math.random();\n    });\n    const sourceNeighbours = isOnEdge(source)\n        ? getNeighbours(source, rows, columns)\n        : [];\n    const targetNeighbours = isOnEdge(target)\n        ? getNeighbours(target, rows, columns)\n        : [];\n    return walls.filter(\n        (wall) =>\n            !isEqual(wall, source) &&\n            !isEqual(wall, target) &&\n            (wall.y !== columns - 1 || wall.x === 1 || wall.x === rows) &&\n            !sourceNeighbours.some((node) => isEqual(node, wall)) &&\n            !targetNeighbours.some((node) => isEqual(node, wall))\n    );\n};\n\nexport default generateRandomMaze;\n","import React, { Component } from \"react\";\nimport \"./navbar.css\";\nimport logo from \"../../logo.svg\";\nimport NavItem from \"./NavItem/navitem\";\nimport generateBinaryTreeMaze from \"../../algorithms/mazeGeneratingAlgorithms/binary_tree\";\nimport generateDFSMaze from \"../../algorithms/mazeGeneratingAlgorithms/dfs\";\nimport generateRecursiveDivisionMaze from \"../../algorithms/mazeGeneratingAlgorithms/recursive_division\";\nimport generateRandomMaze from \"../../algorithms/mazeGeneratingAlgorithms/random\";\n\nclass NavBar extends Component {\n    state = {\n        algorithms: [\n            {\n                id: \"algo-dijkstra\",\n                name: \"Dijkstra's\",\n                description: (\n                    <div>\n                        <p>\n                            Let the node at which we are starting be called the\n                            <b>initial node</b>. Let the\n                            <b>\n                                distance of node\n                                <i>Y</i>\n                            </b>\n                            be the distance from the <b> initial node</b>\n                            to\n                            <i>Y</i>. Dijkstra's algorithm will assign some\n                            initial distance values and will try to improve them\n                            step by step.\n                        </p>\n                        <ol>\n                            <li>\n                                Mark all nodes unvisited. Create a set of all\n                                the unvisited nodes called the\n                                <i>unvisited set</i>.\n                            </li>\n                            <li>\n                                Assign to every node a tentative distance value:\n                                set it to zero for our initial node and to\n                                infinity for all other nodes. Set the initial\n                                node as current.\n                            </li>\n                            <li>\n                                For the current node, consider all of its\n                                unvisited neighbours and calculate their\n                                <i>tentative</i>\n                                distances through the current node. Compare the\n                                newly calculated\n                                <i>tentative</i>\n                                distance to the current assigned value and\n                                assign the smaller one. For example, if the\n                                current node\n                                <i>A</i>\n                                is marked with a distance of 6, and the edge\n                                connecting it with a neighbour\n                                <i>B</i>\n                                has length 2, then the distance to\n                                <i>B</i>\n                                through\n                                <i>A</i>\n                                will be 6 + 2 = 8. If B was previously marked\n                                with a distance greater than 8 then change it to\n                                8. Otherwise, the current value will be kept.\n                            </li>\n                            <li>\n                                When we are done considering all of the\n                                unvisited neighbours of the current node, mark\n                                the current node as visited and remove it from\n                                the\n                                <i>unvisited set</i>. A visited node will never\n                                be checked again.\n                            </li>\n                            <li>\n                                If the destination node has been marked visited\n                                (when planning a route between two specific\n                                nodes) or if the smallest tentative distance\n                                among the nodes in the\n                                <i>unvisited set</i>\n                                is infinity (when planning a complete traversal;\n                                occurs when there is no connection between the\n                                initial node and remaining unvisited nodes),\n                                then stop. The algorithm has finished.\n                            </li>\n                            <li>\n                                Otherwise, select the unvisited node that is\n                                marked with the smallest tentative distance, set\n                                it as the new \"current node\", and go back to\n                                step 3.\n                            </li>\n                        </ol>\n                        <p>\n                            When planning a route, it is actually not necessary\n                            to wait until the destination node is \"visited\" as\n                            above: the algorithm can stop once the destination\n                            node has the smallest tentative distance among all\n                            \"unvisited\" nodes (and thus could be selected as the\n                            next \"current\").\n                        </p>\n                    </div>\n                ),\n            },\n            {\n                id: \"algo-a*\",\n                name: \"A*\",\n                description: (\n                    <div>\n                        <p>\n                            We create two lists  <i>Open List</i> and{\" \"}\n                            <i>Closed List</i>\n                            (just like Dijkstra Algorithm)\n                        </p>\n                        <p>\n                            1. Initialize the open list\n                            <br />\n                            2. Initialize the closed list put the starting node\n                            on the open list (you can leave its{\" \"}\n                            <strong>f</strong> at zero)\n                            <br />\n                            3. while the open list is not empty <br />\n                            a. find the node with the least <strong>\n                                f\n                            </strong>{\" \"}\n                            on the open list, call it \"q\" <br />\n                            b. pop q off the open list <br />\n                            c. generate q's 8 successors and set their parents\n                            to q <br />\n                            d. for each successor <br />\n                            i. if successor is the goal, stop search successor.\n                            <strong>g</strong> = q.<strong>g</strong> + distance\n                            between successor and q successor.<strong>h</strong>{\" \"}\n                            = distance from goal to successor (This can be done\n                            using many ways, we will discuss three heuristics-\n                            Manhattan, Diagonal and Euclidean Heuristics)\n                            successor.<strong>f</strong> = successor.\n                            <strong>g</strong> + successor.<strong>h</strong>\n                            <br />\n                            ii. if a node with the same position as successor is\n                            in the OPEN list which has a lower{\" \"}\n                            <strong>f</strong> than successor, skip this\n                            successor <br />\n                            iii. if a node with the same position as successor\n                            is in the CLOSED list which has a lower{\" \"}\n                            <strong>f</strong> than successor, skip this\n                            successor otherwise, add the node to the open list\n                            end (for loop) e. push q on the closed list end\n                            (while loop){\" \"}\n                        </p>\n                    </div>\n                ),\n            },\n            {\n                id: \"algo-greedy\",\n                name: \"Greedy\",\n                description: (\n                    <div>\n                        <p>\n                            A<b>greedy algorithm</b>\n                            is any algorithm that follows the problem-solving\n                            heuristic of making the locally optimal choice at\n                            each stage. In many problems, a greedy strategy does\n                            not usually produce an optimal solution, but\n                            nonetheless a greedy heuristic may yield locally\n                            optimal solutions that approximate a globally\n                            optimal solution in a reasonable amount of time.\n                        </p>\n                        <p>\n                            For example, a greedy strategy for the\n                            <a\n                                href=\"/wiki/Travelling_salesman_problem\"\n                                title=\"Travelling salesman problem\"\n                            >\n                                travelling salesman problem\n                            </a>\n                            (which is of a high computational complexity) is the\n                            following heuristic: \"At each step of the journey,\n                            visit the nearest unvisited city.\" This heuristic\n                            does not intend to find a best solution, but it\n                            terminates in a reasonable number of steps; finding\n                            an optimal solution to such a complex problem\n                            typically requires unreasonably many steps. In\n                            mathematical optimization, greedy algorithms\n                            optimally solve combinatorial problems having the\n                            properties of\n                            <a href=\"/wiki/Matroid\" title=\"Matroid\">\n                                matroids\n                            </a>\n                            , and give constant-factor approximations to\n                            optimization problems with submodular structure.\n                        </p>\n                    </div>\n                ),\n            },\n            {\n                id: \"algo-bfs\",\n                name: \"Breadth-First-Search\",\n                description: (\n                    <div>\n                        <p>\n                            Visit all the siblings before exploring the children\n                        </p>\n                    </div>\n                ),\n            },\n            {\n                id: \"algo-dfs\",\n                name: \"Depth-First-Search\",\n                description: (\n                    <div>\n                        <p>\n                            Visit all the children before exploring the siblings\n                        </p>\n                    </div>\n                ),\n            },\n        ],\n        mazes: [\n            { id: \"maze-none\", name: \"Create\" },\n            { id: \"maze-binary-tree\", name: \"Binary Tree\" },\n            { id: \"maze-dfs\", name: \"Depth First Search\" },\n            { id: \"maze-recursive-division\", name: \"Recursive Division\" },\n            { id: \"maze-random\", name: \"Random Maze\" },\n        ],\n        speeds: [\n            { id: \"speed-faster\", name: \"Faster\", speed: 10 },\n            { id: \"speed-fast\", name: \"Fast\", speed: 15 },\n            { id: \"speed-normal\", name: \"Normal\", speed: 20 },\n            { id: \"speed-slow\", name: \"Slow\", speed: 30 },\n            { id: \"speed-slower\", name: \"Slower\", speed: 40 },\n        ],\n        selectedMazeId: \"maze-none\",\n    };\n\n    constructMaze = (walls) => {\n        for (let i = 0; i < walls.length; i++) {\n            const wall = walls[i];\n            setTimeout(() => {\n                const nodeDom = document.querySelector(\n                    `#node-${wall.x}-${wall.y}`\n                );\n                nodeDom.classList.remove(\"node-unvisited\");\n                nodeDom.classList.add(\"node-wall\");\n                if (i === walls.length - 1) {\n                    setTimeout(() => {\n                        this.props.stopLoading();\n                        this.props.onMazeCreated(walls, []);\n                    }, this.props.speed);\n                }\n            }, (this.props.speed * i) / 2);\n        }\n    };\n\n    getSelectedMazeFunction = (mazeId) => {\n        switch (mazeId) {\n            case \"maze-binary-tree\":\n                return generateBinaryTreeMaze;\n            case \"maze-dfs\":\n                return generateDFSMaze;\n            case \"maze-recursive-division\":\n                return generateRecursiveDivisionMaze;\n            case \"maze-random\":\n                return generateRandomMaze;\n            case \"maze-none\":\n                return -1;\n            default:\n                return null;\n        }\n    };\n\n    setMazeId = (selectedMazeId) => {\n        const generateMaze = this.getSelectedMazeFunction(selectedMazeId);\n        if (generateMaze === null) {\n            alert(\"Coming Soon !!!\");\n            return;\n        }\n        const dom = document.querySelector(\".maze-options-container\");\n        dom.classList.remove(\"show\");\n        this.props.resetMesh(); // clear the maze\n        this.setState({ selectedMazeId });\n        if (generateMaze === -1) return;\n        this.props.startLoading();\n        console.log(\"Generate Maze : \", selectedMazeId);\n        const wallsInOrder = generateMaze(\n            this.props.rows,\n            this.props.columns,\n            this.props.source,\n            this.props.target\n        );\n        this.constructMaze(wallsInOrder);\n    };\n\n    showAlgorithmOptionsContainer() {\n        // $(\".navbar-collapse\").collapse(\"hide\");\n        const dom = document.querySelector(\".algorithm-options-container\");\n        dom.classList.add(\"show\");\n    }\n\n    showMazeOptionsContainer() {\n        // $(\".navbar-collapse\").collapse(\"hide\");\n        const dom = document.querySelector(\".maze-options-container\");\n        dom.classList.add(\"show\");\n    }\n\n    showSpeedOptionsContainer() {\n        // $(\".navbar-collapse\").collapse(\"hide\");\n        const dom = document.querySelector(\".speed-options-container\");\n        dom.classList.add(\"show\");\n    }\n\n    getSelectedAlgorithm(selectedAlgorithmId) {\n        const algorithm = this.state.algorithms.filter(\n            (algorithm) => algorithm.id === selectedAlgorithmId\n        );\n        return algorithm[0];\n    }\n\n    getSelectedMaze(selectedMazeId) {\n        const maze = this.state.mazes.filter(\n            (maze) => maze.id === selectedMazeId\n        );\n        return maze[0];\n    }\n\n    getSelectedSpeed(selectedSpeedId) {\n        const speed = this.state.speeds.filter(\n            (speed) => speed.id === selectedSpeedId\n        );\n        return speed[0];\n    }\n\n    render() {\n        const {\n            selectedAlgorithmId,\n            selectedSpeedId,\n            onAlgorithmChanged,\n            onSpeedChanged,\n            startWalking,\n            clearPath,\n            destructWalls,\n            resetMesh,\n        } = this.props;\n        return (\n            <React.Fragment>\n                <nav className=\"navbar-custom\">\n                    <span className=\"brand\">\n                        <img\n                            src={logo}\n                            width=\"30\"\n                            height=\"30\"\n                            className=\"d-inline-block align-top\"\n                            alt=\"logo\"\n                        />\n                        <span className=\"my-auto\">Walk to the Destination</span>\n                    </span>\n                    <div className=\"actions-container\">\n                        <button id=\"btn-clear-path\" onClick={() => clearPath()}>\n                            <span>Clear Path</span>\n                            <i className=\"fas fa-eraser\"></i>\n                        </button>\n                        <button\n                            id=\"btn-desctruct-walls\"\n                            onClick={() => destructWalls()}\n                        >\n                            <span>Destruct Walls</span>\n                            <i className=\"fas fa-snowplow\"></i>\n                        </button>\n                        <button id=\"btn-reset-mesh\" onClick={() => resetMesh()}>\n                            <span>Reset Mesh</span>\n                            <i className=\"fas fa-trash-restore\"></i>\n                        </button>\n                        <button\n                            id=\"btn-start-walking\"\n                            onClick={() => startWalking()}\n                        >\n                            <span>Start Walking</span>\n                            <i className=\"fas fa-play-circle\"></i>\n                        </button>\n                    </div>\n                    <div className=\"walking-options\">\n                        <ul>\n                            <li>\n                                <button\n                                    className=\"btn-algorithm\"\n                                    onClick={this.showAlgorithmOptionsContainer}\n                                >\n                                    <span>\n                                        {\n                                            this.getSelectedAlgorithm(\n                                                selectedAlgorithmId\n                                            ).name\n                                        }\n                                    </span>{\" \"}\n                                    Algorithm\n                                    <i className=\"fas fa-check-double ml-1\"></i>\n                                </button>\n                            </li>\n                            <li>\n                                <button\n                                    className=\"btn-maze\"\n                                    onClick={this.showMazeOptionsContainer}\n                                >\n                                    <span>\n                                        {\n                                            this.getSelectedMaze(\n                                                this.state.selectedMazeId\n                                            ).name\n                                        }\n                                    </span>{\" \"}\n                                    Maze\n                                    <i className=\"fab fa-magento ml-1\"></i>\n                                </button>\n                            </li>\n                            <li>\n                                <button\n                                    className=\"btn-speed\"\n                                    onClick={this.showSpeedOptionsContainer}\n                                >\n                                    Speed :{\" \"}\n                                    <span>\n                                        {\n                                            this.getSelectedSpeed(\n                                                selectedSpeedId\n                                            ).name\n                                        }\n                                    </span>{\" \"}\n                                    <i className=\"fas fa-tachometer-alt\"></i>\n                                </button>\n                            </li>\n                        </ul>\n                    </div>\n                </nav>\n                <div className=\"algorithm-options-container\">\n                    <NavItem\n                        options={this.state.algorithms}\n                        selectedOption={selectedAlgorithmId}\n                        onChanged={onAlgorithmChanged}\n                    />\n                </div>\n                <div className=\"maze-options-container\">\n                    <NavItem\n                        options={this.state.mazes}\n                        selectedOption={this.state.selectedMazeId}\n                        onChanged={this.setMazeId}\n                    />\n                </div>\n                <div className=\"speed-options-container\">\n                    <NavItem\n                        options={this.state.speeds}\n                        selectedOption={selectedSpeedId}\n                        onChanged={onSpeedChanged}\n                    />\n                </div>\n            </React.Fragment>\n        );\n    }\n}\n\nexport default NavBar;\n","const NodeState = {\n    NODE_UNVISITED: 0,\n    NODE_VISITED: 1,\n    NODE_IS_WALL: -1,\n    NODE_IS_SOURCE: 10,\n    NODE_IS_TARGET: 100,\n    NODE_FALLS_IN_PATH: 50,\n    NODE_IS_VISITING: 2,\n};\nexport default NodeState;\n","import React, { Component } from \"react\";\nimport \"./node.css\";\nimport NodeState from \"./node_state\";\nclass Node extends Component {\n    render() {\n        const {\n            nodeState,\n            position,\n            onMouseDown,\n            onMouseUp,\n            onMouseEnter,\n            onMouseLeave,\n        } = this.props;\n        if (onMouseEnter === undefined) {\n            return (\n                <div className={this.getNodeStateClass(nodeState)}>\n                    {/* <div></div> */}\n                </div>\n            );\n        } else {\n            return (\n                <div\n                    className={this.getNodeStateClass(nodeState)}\n                    id={`node-${position.x}-${position.y}`}\n                    data-x={position.x}\n                    data-y={position.y}\n                    onMouseDown={() => onMouseDown(nodeState, position)}\n                    onMouseUp={() => onMouseUp(nodeState, position)}\n                    onMouseEnter={() => onMouseEnter(nodeState, position)}\n                    onMouseLeave={() => onMouseLeave(nodeState, position)}\n                >\n                    {/* <div></div> */}\n                </div>\n            );\n        }\n    }\n\n    getNodeStateClass(nodeState) {\n        let classes = \"node node-\";\n        switch (nodeState) {\n            case NodeState.NODE_UNVISITED:\n                classes += \"unvisited\";\n                break;\n            case NodeState.NODE_VISITED:\n                classes += \"visited\";\n                break;\n            case NodeState.NODE_IS_WALL:\n                classes += \"wall\";\n                break;\n            case NodeState.NODE_IS_SOURCE:\n                classes += \"source\";\n                break;\n            case NodeState.NODE_IS_TARGET:\n                classes += \"target\";\n                break;\n            default:\n                classes += \"unvisited\";\n                break;\n        }\n        return classes;\n    }\n}\n\nexport default Node;\n","import React from \"react\";\nimport \"./legend.css\";\nimport Node from \"../Node/node\";\nimport Position from \"../../helper/position\";\nimport NodeState from \"../Node/node_state\";\n\nconst Legend = () => {\n    return (\n        <section className=\"legend-container\">\n            <ul>\n                <li>\n                    <div>\n                        <Node\n                            nodeState={NodeState.NODE_UNVISITED}\n                            position={new Position(-1, -1)}\n                            disabled\n                        />\n                        <span className=\"ml-1\">Unvisited</span>\n                    </div>\n                </li>\n                <li>\n                    <div>\n                        <Node\n                            nodeState={NodeState.NODE_VISITED}\n                            position={new Position(-1, -1)}\n                        />\n                        <span className=\"ml-1\">Visited</span>\n                    </div>\n                </li>\n                <li>\n                    <div>\n                        <Node\n                            nodeState={NodeState.NODE_IS_WALL}\n                            position={new Position(-1, -1)}\n                        />\n                        <span className=\"ml-1\">Wall</span>\n                    </div>\n                </li>\n                <li>\n                    <div>\n                        <Node\n                            nodeState={NodeState.NODE_IS_SOURCE}\n                            position={new Position(-1, -1)}\n                        />\n                        <span className=\"ml-1\">Source</span>\n                    </div>\n                </li>\n                <li>\n                    <div>\n                        <Node\n                            nodeState={NodeState.NODE_IS_TARGET}\n                            position={new Position(-1, -1)}\n                        />\n                        <span className=\"ml-1\">Target</span>\n                    </div>\n                </li>\n            </ul>\n        </section>\n    );\n};\n\nexport default Legend;\n","import React, { Component } from \"react\";\nimport Node from \"../Node/node\";\nimport NodeState from \"../Node/node_state\";\nimport Position from \"../../helper/position\";\nimport \"./grid.css\";\n\nclass Grid extends Component {\n    state = {\n        isMousePressed: false,\n        movingSource: false,\n        movingTarget: false,\n    };\n\n    handleMouseUp(nodeState, position) {\n        this.setState({ isMousePressed: false });\n        // console.log(\n        //     `(${position.x}, ${position.y}) : mouseUp | pressed=${this.state.isMousePressed}`\n        // );\n        if (nodeState === NodeState.NODE_IS_SOURCE) {\n            this.setState({ movingSource: false });\n        } else if (nodeState === NodeState.NODE_IS_TARGET) {\n            this.setState({ movingTarget: false });\n        } else {\n            // do nothing\n        }\n    }\n    handleMouseDown(nodeState, position) {\n        this.setState({ isMousePressed: true });\n        // console.log(\n        //     `(${position.x}, ${position.y}) : mouseDown | pressed=${this.state.isMousePressed}`\n        // );\n        if (nodeState === NodeState.NODE_IS_SOURCE) {\n            this.setState({ movingSource: true });\n        } else if (nodeState === NodeState.NODE_IS_TARGET) {\n            this.setState({ movingTarget: true });\n        } else {\n            this.props.toggleWall(position);\n        }\n    }\n    handleMouseEnter(nodeState, position) {\n        if (this.state.isMousePressed) {\n            // console.log(\n            //     `(${position.x}, ${position.y}) : mouseEnter | pressed=${this.state.isMousePressed}`\n            // );\n            if (this.state.movingSource) {\n                // TODO: change nodeState to source\n                this.props.setNodeAsSource(position);\n            } else if (this.state.movingTarget) {\n                // TODO: change nodeState to target\n                this.props.setNodeAsTarget(position);\n            } else {\n                // TODO: toggleWall()\n                // console.log(position);\n                this.props.toggleWall(position);\n            }\n        }\n    }\n    handleMouseLeave(nodeState, position) {\n        // if (this.state.isMousePressed) {\n        //     console.log(\n        //         `(${position.x}, ${position.y}) : mouseLeave | pressed=${this.state.isMousePressed}`\n        //     );\n        //     if (nodeState === NodeState.NODE_IS_SOURCE) {\n        //         // TODO: change nodeState to unvisited\n        //     } else if (nodeState === NodeState.NODE_IS_TARGET) {\n        //         // TODO: change nodestate to unvisited\n        //     } else {\n        //         // do nothing\n        //     }\n        // }\n    }\n\n    decideNodeState(x, y, source, target, walls, visitedNodes) {\n        if (x === source.x && y === source.y) {\n            return NodeState.NODE_IS_SOURCE;\n        } else if (x === target.x && y === target.y) {\n            return NodeState.NODE_IS_TARGET;\n        } else if (\n            walls.some((position) => position.x === x && position.y === y)\n        ) {\n            return NodeState.NODE_IS_WALL;\n        } else if (\n            visitedNodes.some(\n                (position) => position.x === x && position.y === y\n            )\n        ) {\n            return NodeState.NODE_VISITED;\n        }\n        return NodeState.NODE_UNVISITED;\n    }\n\n    render() {\n        const {\n            rows,\n            columns,\n            source,\n            target,\n            walls,\n            visitedNodes,\n        } = this.props;\n        const paddingX = (window.innerWidth - columns * 20) / 2;\n        const paddingY = (window.innerHeight - 190 - rows * 20) / 2;\n        const nodes = [];\n\n        for (var x = 1; x <= rows; x++) {\n            for (var y = 1; y <= columns; y++) {\n                const key = \"node-\" + x + \"-\" + y;\n                const nodeState = this.decideNodeState(\n                    x,\n                    y,\n                    source,\n                    target,\n                    walls,\n                    visitedNodes\n                );\n\n                nodes.push(\n                    <Node\n                        key={key}\n                        position={new Position(x, y)}\n                        id={key}\n                        nodeState={nodeState}\n                        onMouseDown={(nodeState, position) =>\n                            this.handleMouseDown(nodeState, position)\n                        }\n                        onMouseUp={(nodeState, position) =>\n                            this.handleMouseUp(nodeState, position)\n                        }\n                        onMouseEnter={(nodeState, position) =>\n                            this.handleMouseEnter(nodeState, position)\n                        }\n                        onMouseLeave={(nodeState, position) =>\n                            this.handleMouseLeave(nodeState, position)\n                        }\n                    />\n                );\n            }\n        }\n        return (\n            <section\n                className=\"grid-container\"\n                style={{\n                    paddingTop: paddingY,\n                    paddingRight: paddingX,\n                    paddingBottom: paddingY,\n                    paddingLeft: paddingX,\n                }}\n            >\n                {nodes}\n            </section>\n        );\n    }\n}\n\nexport default Grid;\n","import React from \"react\";\nimport \"./insights.css\";\n\nconst Insights = (props) => {\n    const { insights } = props;\n    return (\n        <section className=\"insights-container\">\n            <div>\n                <p>{insights}</p>\n            </div>\n        </section>\n    );\n};\n\nexport default Insights;\n","import React from \"react\";\nimport \"./copyright.css\";\nconst Copyright = () => {\n    return (\n        <section className=\"copyright-container\">\n            <div className=\"github-links\">\n                <a href=\"https://github.com/shantanu0323\">\n                    <i className=\"fab fa-github-square\"></i>\n                </a>\n            </div>\n            <div className=\"copyright\">\n                Made with <i className=\"fas fa-heart text-danger\"></i> by{\" \"}\n                <a href=\"https://shantanu0323.github.io\">Shantanu Pramanik</a>\n            </div>\n            <div className=\"social-links\">\n                <a href=\"https://www.linkedin.com/in/shantanu-pramanik/\">\n                    <i className=\"fab fa-linkedin\"></i>\n                </a>\n                <a href=\"https://www.facebook.com/shantanu.pramanik1\">\n                    <i className=\"fab fa-facebook-square\"></i>\n                </a>\n                <a href=\"https://www.twitter.com/shantanu0323/\">\n                    <i className=\"fab fa-twitter-square\"></i>\n                </a>\n                <a href=\"https://www.instagram.com/shantanu0323/\">\n                    <i className=\"fab fa-instagram-square\"></i>\n                </a>\n            </div>\n        </section>\n    );\n};\n\nexport default Copyright;\n","import NodeState from \"../components/Node/node_state\";\nimport Position, { isEqual, getNeighbours } from \"../helper/position\";\n\nclass Node {\n    constructor(\n        position,\n        distance = Infinity,\n        nodeState = NodeState.NODE_UNVISITED\n    ) {\n        this.position = position;\n        this.distance = distance;\n        this.nodeState = nodeState;\n    }\n}\n\nconst mesh = [];\nlet unvisitedNodes = [];\n\nconst initialiseMesh = (rows, columns, source, target, walls) => {\n    window.rows = rows;\n    window.columns = columns;\n    mesh.length = 0;\n    unvisitedNodes.length = 0;\n    for (let i = 1; i <= window.rows; i++) {\n        const row = [];\n        for (let j = 1; j <= window.columns; j++) {\n            const node = new Node(new Position(i, j));\n            if (isEqual(node.position, source)) {\n                node.nodeState = NodeState.NODE_IS_SOURCE;\n                node.distance = 0;\n            } else if (isEqual(node.position, target)) {\n                node.nodeState = NodeState.NODE_IS_TARGET;\n            }\n            unvisitedNodes.push(node);\n            row[j] = node;\n        }\n        mesh[i] = row;\n    }\n    walls.forEach((position) => {\n        mesh[position.x][position.y].nodeState = NodeState.NODE_IS_WALL;\n    });\n};\n\nconst getNonWallNeighbours = (node) => {\n    const neighbourPositions = getNeighbours(\n        node.position,\n        window.rows,\n        window.columns\n    );\n    const neighbours = [];\n    neighbourPositions.map((position) => {\n        const node = mesh[position.x][position.y];\n        if (node.nodeState !== NodeState.NODE_IS_WALL) {\n            neighbours.push(node);\n            return true;\n        }\n        return false;\n    });\n\n    return neighbours;\n};\n\nconst getPreviousNodeInPath = (currNode) => {\n    const neighbours = getNonWallNeighbours(currNode).filter(\n        (node) =>\n            mesh[node.position.x][node.position.y].nodeState ===\n            NodeState.NODE_VISITED\n    );\n    let min = Infinity;\n    let prevNode;\n    for (let i = 0; i < neighbours.length; i++) {\n        const node = neighbours[i];\n        if (node.distance < min) {\n            min = node.distance;\n            prevNode = node;\n        }\n    }\n    return prevNode;\n};\n\nconst getNodesInPath = (visitedNodes) => {\n    const path = [];\n    let currNode = visitedNodes[visitedNodes.length - 1]; // target\n    while (currNode.distance > 1) {\n        currNode = getPreviousNodeInPath(currNode);\n        path.unshift(currNode);\n    }\n    return path;\n};\n\nconst getVisitedNodes = (target) => {\n    const visitedNodes = [];\n\n    while (unvisitedNodes.length > 0) {\n        let minDist = Infinity;\n        let currNode = undefined;\n        for (let i = 0; i < unvisitedNodes.length; i++) {\n            if (unvisitedNodes[i].distance < minDist) {\n                minDist = unvisitedNodes[i].distance;\n                currNode = unvisitedNodes[i];\n            }\n        }\n        if (currNode === undefined) {\n            console.log(\"Target NOT Reachable\");\n            break;\n        }\n\n        visitedNodes.push(currNode);\n        unvisitedNodes = unvisitedNodes.filter(\n            (node) => !isEqual(node.position, currNode.position)\n        );\n        if (isEqual(currNode.position, target)) {\n            console.log(\"TARGET REACHED\");\n            break;\n        }\n        currNode.nodeState =\n            currNode.nodeState === NodeState.NODE_IS_SOURCE\n                ? NodeState.NODE_IS_SOURCE\n                : NodeState.NODE_VISITED;\n\n        getNonWallNeighbours(currNode).forEach((node) => {\n            const alt = currNode.distance + 1;\n            node.distance = alt < node.distance ? alt : node.distance;\n        });\n    }\n\n    return visitedNodes;\n};\n\nconst performDijkstra = (rows, columns, source, target, walls) => {\n    // initialise and fetch the graph\n    initialiseMesh(rows, columns, source, target, walls);\n\n    // perform dijkstra(graph, source, target) on the graph and get the visited nodes in order\n    const visitedNodesObjects = getVisitedNodes(target);\n    const pathObjects = getNodesInPath(visitedNodesObjects);\n    const visitedNodes = [];\n    const path = [];\n    visitedNodesObjects.map((node) => visitedNodes.push(node.position));\n    pathObjects.map((node) => path.push(node.position));\n    return { visitedNodes, path };\n};\n\nexport default performDijkstra;\n","const resetSourceAndTarget = () => {\n    const sourceDom = document.querySelector(\".node.node-source\");\n    sourceDom.classList.remove(\"path-to-top\");\n    sourceDom.classList.remove(\"path-to-right\");\n    sourceDom.classList.remove(\"path-to-bottom\");\n    sourceDom.classList.remove(\"path-to-left\");\n\n    const targetDom = document.querySelector(\".node.node-target\");\n    targetDom.classList.remove(\"path-to-top\");\n    targetDom.classList.remove(\"path-to-right\");\n    targetDom.classList.remove(\"path-to-bottom\");\n    targetDom.classList.remove(\"path-to-left\");\n};\n\nexport default resetSourceAndTarget;\n","import React from \"react\";\nimport \"./loader.css\";\nconst Loader = (props) => {\n    const classes = props.loading\n        ? \"loader-container show\"\n        : \"loader-container hide\";\n    return (\n        <div className={classes}>\n            <div className=\"top-bar\"></div>\n            <div className=\"right-bar\"></div>\n            <div className=\"bottom-bar\"></div>\n            <div className=\"left-bar\"></div>\n        </div>\n    );\n};\n\nexport default Loader;\n","import NodeState from \"../components/Node/node_state\";\nimport Position, { isEqual, getNeighbours } from \"../helper/position\";\n\nclass Node {\n    constructor(position, nodeState = NodeState.NODE_UNVISITED) {\n        this.position = position;\n        this.parent = null;\n        this.f = Infinity;\n        this.g = Infinity;\n        this.h = Infinity;\n        this.nodeState = nodeState;\n    }\n}\n\nlet openList = [];\nconst closedList = [];\n\nconst distance = (a, b) => {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n    // return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n};\n\nconst initialiseMesh = (rows, columns, source, target, walls) => {\n    openList.length = 0;\n    closedList.length = 0;\n    window.rows = rows;\n    window.columns = columns;\n\n    const sourceNode = new Node(source, NodeState.NODE_IS_SOURCE);\n    sourceNode.g = 0;\n    sourceNode.h = distance(source, target);\n    sourceNode.f = sourceNode.h;\n    openList.push(sourceNode);\n};\n\nconst getTraversableNeighbours = (node, walls) => {\n    const neighbourPositions = getNeighbours(node, window.rows, window.columns);\n    const neighbours = [];\n    neighbourPositions\n        .filter(\n            (position) =>\n                !(\n                    walls.some((wall) => isEqual(wall, position)) ||\n                    closedList.some((node) => isEqual(node.position, position))\n                )\n        )\n        .map((position) => {\n            neighbours.push(new Node(new Position(position.x, position.y)));\n            return true;\n        });\n\n    return neighbours;\n};\n\nconst nodeWithLeastF = () => {\n    openList.sort((a, b) => {\n        return a.f === b.f ? a.h > b.h : a.f > b.f;\n    });\n    return openList[0];\n};\n\nconst performAstar = (rows, columns, source, target, walls) => {\n    // initialise and fetch the graph\n    // add source to the openList\n    initialiseMesh(rows, columns, source, target, walls);\n    // START LOOP\n    // let k = 2000;\n    while (\n        openList.length > 0 &&\n        closedList.length < rows * columns - walls.length\n    ) {\n        // k--;\n        // console.log(closedList.length);\n        // CURRENT = node in the openList with the least f_cost\n        const currNode = nodeWithLeastF();\n        // console.log(\"CURRENT: \", JSON.parse(JSON.stringify(currNode)));\n        // remove current from the openList\n        openList.shift();\n        // add current to the closedList\n        closedList.push(currNode);\n        // console.log(\"OPEN: \", JSON.parse(JSON.stringify(openList)));\n        // console.log(\"CLOSED: \", JSON.parse(JSON.stringify(closedList)));\n\n        // if current = target then return\n        if (isEqual(currNode.position, target)) break;\n\n        // FOREACH neighbour of the CURRENT\n        getTraversableNeighbours(currNode.position, walls).map((neighbour) => {\n            // if neighbour is not traversable or neighbour in the closedList\n            // then skip to the next neighbour\n            // set the f_cost of the neighbour\n            neighbour.g =\n                currNode.g + distance(neighbour.position, currNode.position);\n            neighbour.h = distance(neighbour.position, target);\n            neighbour.f = neighbour.g + neighbour.h;\n            // set parent of the neighbour to the current\n            neighbour.parent = currNode;\n            // console.log(\n            //     `Neighbour(${neighbour.position.x},${neighbour.position.y}): `,\n            //     JSON.parse(JSON.stringify(neighbour))\n            // );\n            // if new path to neighbour is shorter or if the neighbour is NOT in openList\n            let found = false;\n            for (let i = 0; i < openList.length; i++) {\n                if (\n                    isEqual(openList[i].position, neighbour.position) &&\n                    neighbour.f < openList[i].f\n                ) {\n                    openList[i] = neighbour;\n                    found = true;\n                    break;\n                }\n            }\n            // if neighbour is not in openlist then add it to openList\n            if (!found) {\n                openList.push(neighbour);\n            }\n            return true;\n        });\n\n        // END LOOP\n    }\n    // console.log(\"CLOSED: \", JSON.parse(JSON.stringify(closedList)));\n    const visitedNodes = [];\n    closedList\n        .filter(\n            (node) =>\n                node.nodeState !== NodeState.NODE_IS_SOURCE &&\n                node.nodeState !== NodeState.NODE_IS_TARGET\n        )\n        .map((node) => visitedNodes.push(node.position));\n    const path = [];\n    let node = closedList[closedList.length - 1];\n    while (node !== null) {\n        if (!isEqual(node.position, source) && !isEqual(node.position, target))\n            path.unshift(node.position);\n        node = node.parent;\n    }\n    return { visitedNodes, path };\n};\n\nexport default performAstar;\n","import NodeState from \"../components/Node/node_state\";\nimport Position, { isEqual, getNeighbours } from \"../helper/position\";\n\nclass Node {\n    constructor(position, nodeState = NodeState.NODE_UNVISITED) {\n        this.position = position;\n        this.parent = null;\n        this.f = Infinity;\n        this.nodeState = nodeState;\n    }\n}\n\nlet openList = [];\nconst closedList = [];\n\nconst distance = (a, b) => {\n    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n    // return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n};\n\nconst initialiseMesh = (rows, columns, source, target, walls) => {\n    openList.length = 0;\n    closedList.length = 0;\n    window.rows = rows;\n    window.columns = columns;\n\n    const sourceNode = new Node(source, NodeState.NODE_IS_SOURCE);\n    sourceNode.f = distance(source, target);\n    openList.push(sourceNode);\n};\n\nconst getTraversableNeighbours = (node, walls) => {\n    const neighbourPositions = getNeighbours(node, window.rows, window.columns);\n    const neighbours = [];\n    neighbourPositions\n        .filter(\n            (position) =>\n                !(\n                    walls.some((wall) => isEqual(wall, position)) ||\n                    closedList.some((node) => isEqual(node.position, position))\n                )\n        )\n        .map((position) => {\n            neighbours.push(new Node(new Position(position.x, position.y)));\n            return true;\n        });\n\n    return neighbours;\n};\n\nconst nodeWithLeastF = () => {\n    openList.sort((a, b) => {\n        return a.f > b.f;\n    });\n    return openList[0];\n};\n\nconst performGreedy = (rows, columns, source, target, walls) => {\n    // initialise and fetch the graph\n    // add source to the openList\n    initialiseMesh(rows, columns, source, target, walls);\n    // START LOOP\n    // let k = 2000;\n    while (\n        openList.length > 0 &&\n        closedList.length < rows * columns - walls.length\n    ) {\n        // k--;\n        // console.log(closedList.length);\n        // CURRENT = node in the openList with the least f_cost\n        const currNode = nodeWithLeastF();\n        // console.log(\"CURRENT: \", JSON.parse(JSON.stringify(currNode)));\n        // remove current from the openList\n        openList.shift();\n        // add current to the closedList\n        closedList.push(currNode);\n        // console.log(\"OPEN: \", JSON.parse(JSON.stringify(openList)));\n        // console.log(\"CLOSED: \", JSON.parse(JSON.stringify(closedList)));\n\n        // if current = target then return\n        if (isEqual(currNode.position, target)) break;\n\n        // FOREACH neighbour of the CURRENT\n        getTraversableNeighbours(currNode.position, walls).map((neighbour) => {\n            // if neighbour is not traversable or neighbour in the closedList\n            // then skip to the next neighbour\n            // set the f_cost of the neighbour\n            neighbour.f = distance(neighbour.position, target);\n            // set parent of the neighbour to the current\n            neighbour.parent = currNode;\n            // console.log(\n            //     `Neighbour(${neighbour.position.x},${neighbour.position.y}): `,\n            //     JSON.parse(JSON.stringify(neighbour))\n            // );\n            // if new path to neighbour is shorter or if the neighbour is NOT in openList\n            let found = false;\n            for (let i = 0; i < openList.length; i++) {\n                if (\n                    isEqual(openList[i].position, neighbour.position) &&\n                    neighbour.f < openList[i].f\n                ) {\n                    openList[i] = neighbour;\n                    found = true;\n                    break;\n                }\n            }\n            // if neighbour is not in openlist then add it to openList\n            if (!found) {\n                openList.push(neighbour);\n            }\n            return true;\n        });\n\n        // END LOOP\n    }\n    // console.log(\"CLOSED: \", JSON.parse(JSON.stringify(closedList)));\n    const visitedNodes = [];\n    closedList\n        .filter(\n            (node) =>\n                node.nodeState !== NodeState.NODE_IS_SOURCE &&\n                node.nodeState !== NodeState.NODE_IS_TARGET\n        )\n        .map((node) => visitedNodes.push(node.position));\n    const path = [];\n    let node = closedList[closedList.length - 1];\n    while (node !== null) {\n        if (!isEqual(node.position, source) && !isEqual(node.position, target))\n            path.unshift(node.position);\n        node = node.parent;\n    }\n    return { visitedNodes, path };\n};\n\nexport default performGreedy;\n","import { isEqual, getNeighbours } from \"../helper/position\";\n\nlet visitedNodes = [];\nconst queue = [];\nconst parents = {};\n\nconst getKey = (position) => {\n    return `node-${position.x}-${position.y}`;\n};\n\nconst initialiseMesh = (rows, columns, source, target, walls) => {\n    window.rows = rows;\n    window.columns = columns;\n    window.source = source;\n    window.target = target;\n    visitedNodes.length = 0;\n    queue.length = 0;\n    queue.push(source);\n    parents[getKey(source)] = null;\n};\n\nconst getNonWallUnvisitedNeighbours = (node, walls) => {\n    const neighbourPositions = getNeighbours(node, window.rows, window.columns);\n    const neighbours = [];\n    neighbourPositions\n        .filter(\n            (neighbour) =>\n                !walls.some((wall) => isEqual(wall, neighbour)) &&\n                !queue.some((queue) => isEqual(queue, neighbour)) &&\n                !visitedNodes.some((visitedNode) =>\n                    isEqual(visitedNode, neighbour)\n                ) &&\n                !isEqual(neighbour, window.source)\n        )\n        .map((neighbour) => {\n            parents[getKey(neighbour)] = node;\n            neighbours.push(neighbour);\n            return true;\n        });\n\n    return neighbours;\n};\n\nconst runBFS = (target, walls) => {\n    while (queue.length > 0) {\n        const currNode = queue[0];\n        visitedNodes.push(currNode);\n\n        if (isEqual(currNode, target)) return;\n\n        queue.shift();\n        getNonWallUnvisitedNeighbours(currNode, walls).map((neighbour) =>\n            queue.push(neighbour)\n        );\n    }\n};\n\nconst getPath = () => {\n    const path = [];\n    let currNode = window.target;\n    if (!isEqual(visitedNodes[visitedNodes.length - 1], currNode)) return [];\n    while (parents[getKey(currNode)] !== null) {\n        path.unshift(parents[getKey(currNode)]);\n        currNode = parents[getKey(currNode)];\n    }\n    path.shift(); // to remove source\n    return path;\n};\n\nconst performBFS = (rows, columns, source, target, walls) => {\n    // initialise and fetch the graph\n    initialiseMesh(rows, columns, source, target, walls);\n\n    runBFS(target, walls);\n    const path = getPath();\n    return { visitedNodes, path };\n};\n\nexport default performBFS;\n","import { isEqual, getNeighbours } from \"../helper/position\";\n\nlet visitedNodes = [];\nlet parents = {};\nlet targetFound = false;\n\nconst getKey = (position) => {\n    return `node-${position.x}-${position.y}`;\n};\n\nconst initialiseMesh = (rows, columns, source, target) => {\n    window.rows = rows;\n    window.columns = columns;\n    window.source = source;\n    window.target = target;\n    visitedNodes.length = 0;\n    parents = {};\n    targetFound = false;\n    parents[getKey(source)] = null;\n};\n\nconst getNonWallUnvisitedNeighbours = (node, walls) => {\n    const neighbourPositions = getNeighbours(node, window.rows, window.columns);\n    const neighbours = [];\n    neighbourPositions\n        .filter(\n            (neighbour) =>\n                !walls.some((wall) => isEqual(wall, neighbour)) &&\n                !visitedNodes.some((visitedNode) =>\n                    isEqual(visitedNode, neighbour)\n                ) &&\n                !isEqual(neighbour, window.source)\n        )\n        .map((neighbour) => {\n            parents[getKey(neighbour)] = node;\n            neighbours.push(neighbour);\n            return true;\n        });\n\n    return neighbours;\n};\n\nconst runDFS = (currNode, walls) => {\n    if (targetFound) return;\n    if (isEqual(currNode, window.target)) {\n        visitedNodes.push(currNode);\n        targetFound = true;\n        return;\n    }\n    visitedNodes.push(currNode);\n    const neighbours = getNonWallUnvisitedNeighbours(currNode, walls);\n    while (neighbours.length > 0 && !targetFound) {\n        runDFS(neighbours[0], walls);\n        neighbours.shift();\n    }\n};\n\nconst getPath = () => {\n    const path = [];\n    let currNode = window.target;\n    if (!isEqual(visitedNodes[visitedNodes.length - 1], currNode)) return [];\n    while (parents[getKey(currNode)] !== null) {\n        path.unshift(parents[getKey(currNode)]);\n        currNode = parents[getKey(currNode)];\n    }\n    path.shift(); // to remove source\n    return path;\n};\n\nconst performDFS = (rows, columns, source, target, walls) => {\n    // initialise and fetch the graph\n    initialiseMesh(rows, columns, source, target, walls);\n\n    runDFS(source, walls);\n    const path = getPath();\n    return { visitedNodes, path };\n};\n\nexport default performDFS;\n","import React, { Component } from \"react\";\nimport NavBar from \"./components/NavBar/navbar\";\nimport Legend from \"./components/Legend/legend\";\nimport Grid from \"./components/Grid/grid\";\nimport Position, { isEqual } from \"./helper/position\";\nimport Insights from \"./components/Insights/insights\";\nimport Copyright from \"./components/Copyright/copyright\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"./App.css\";\nimport performDijkstra from \"./algorithms/dijkstra\";\nimport resetSourceAndTarget from \"./helper/initialise\";\nimport Loader from \"./components/Loader/loader\";\nimport performAstar from \"./algorithms/a_star\";\nimport performGreedy from \"./algorithms/greedy\";\nimport performBFS from \"./algorithms/bfs\";\nimport performDFS from \"./algorithms/dfs\";\n\nclass App extends Component {\n    componentDidMount() {\n        // Include the FontAwesome Library\n        const s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.async = true;\n        s.crossOrigin = \"anonymous\";\n        s.src = \"https://kit.fontawesome.com/f7fe82406d.js\";\n        document.body.appendChild(s);\n\n        const gridHeight = window.innerHeight - 190;\n        const gridWidth = window.innerWidth;\n\n        const rows = parseInt((gridHeight - 40) / 20);\n\n        const columns = parseInt((gridWidth - 40) / 20);\n        const source = new Position(\n            parseInt(0.5 * rows),\n            parseInt(0.3 * columns)\n        );\n        // const source = new Position(2, 2);\n        const target = new Position(\n            parseInt(0.5 * rows),\n            parseInt(0.7 * columns)\n        );\n        // const target = new Position(4, 5);\n        this.setState({ rows, columns, source, target });\n    }\n\n    state = {\n        selectedAlgorithmId: \"algo-dijkstra\",\n        selectedSpeedId: \"speed-fast\",\n        speed: 15,\n        rows: 0,\n        columns: 0,\n        source: new Position(-1, -1),\n        target: new Position(-1, -1),\n        walls: [],\n        visitedNodes: [],\n        loading: false,\n    };\n\n    startLoading = () => {\n        this.setState({ loading: true });\n    };\n\n    stopLoading = () => {\n        this.setState({ loading: false });\n    };\n\n    setAlgorithmId = (selectedAlgorithmId) => {\n        this.setState({ selectedAlgorithmId });\n        const dom = document.querySelector(\".algorithm-options-container\");\n        dom.classList.remove(\"show\");\n    };\n\n    setSpeedId = (selectedSpeedId, speed) => {\n        this.setState({ selectedSpeedId, speed });\n        const dom = document.querySelector(\".speed-options-container\");\n        dom.classList.remove(\"show\");\n    };\n\n    setNodeAsSource = (position) => {\n        // console.log(`SOURCE: ${position}`);\n        if (\n            !(\n                position.x === this.state.target.x &&\n                position.y === this.state.target.y\n            )\n        ) {\n            let walls = this.state.walls;\n            if (\n                walls.some(\n                    (node) => node.x === position.x && node.y === position.y\n                )\n            ) {\n                walls = this.state.walls.filter(\n                    (node) => !(node.x === position.x && node.y === position.y)\n                );\n            }\n            this.setState({ source: position, walls });\n        }\n    };\n\n    setNodeAsTarget = (position) => {\n        // console.log(`TARGET: ${position}`);\n        if (\n            !(\n                position.x === this.state.source.x &&\n                position.y === this.state.source.y\n            )\n        ) {\n            let walls = this.state.walls;\n            if (\n                walls.some(\n                    (node) => node.x === position.x && node.y === position.y\n                )\n            ) {\n                walls = this.state.walls.filter(\n                    (node) => !(node.x === position.x && node.y === position.y)\n                );\n            }\n            this.setState({ target: position, walls });\n        }\n    };\n\n    toggleWall = (position) => {\n        // console.log(position);\n        let walls = this.state.walls;\n        if (\n            walls.some((node) => node.x === position.x && node.y === position.y)\n        ) {\n            // Node is a wall -> change to unvisited\n            walls = walls.filter(\n                (node) => !(node.x === position.x && node.y === position.y)\n            );\n        } else {\n            walls.push(position);\n        }\n        this.setState({ walls });\n    };\n\n    putNodeInPath = (position, node) => {\n        if (isEqual(position, new Position(node.x - 1, node.y))) return \"top\";\n        if (isEqual(position, new Position(node.x, node.y + 1))) return \"right\";\n        if (isEqual(position, new Position(node.x + 1, node.y)))\n            return \"bottom\";\n        if (isEqual(position, new Position(node.x, node.y - 1))) return \"left\";\n        return \"null\";\n    };\n\n    clearPath = () => {\n        this.setState({ visitedNodes: [] });\n        for (let i = 1; i <= this.state.rows; i++) {\n            for (let j = 1; j <= this.state.columns; j++) {\n                const nodeDom = document.querySelector(`#node-${i}-${j}`);\n                if (\n                    nodeDom.classList.contains(\"node-visited\") ||\n                    nodeDom.classList.contains(\"node-path\")\n                ) {\n                    nodeDom.classList.remove(\"node-visited\");\n                    nodeDom.classList.remove(\"node-path\");\n                    nodeDom.classList.add(\"node-unvisited\");\n                }\n            }\n        }\n        resetSourceAndTarget();\n    };\n\n    destructWalls = () => {\n        this.setState({ walls: [] });\n    };\n\n    resetMesh = () => {\n        this.clearPath();\n        this.destructWalls();\n    };\n\n    getSelectedAlgorithmFunction = () => {\n        switch (this.state.selectedAlgorithmId) {\n            case \"algo-dijkstra\":\n                return performDijkstra;\n            case \"algo-a*\":\n                return performAstar;\n            case \"algo-greedy\":\n                return performGreedy;\n            case \"algo-bfs\":\n                return performBFS;\n            case \"algo-dfs\":\n                return performDFS;\n            default:\n                return null;\n        }\n    };\n\n    startWalking = () => {\n        setTimeout(() => {\n            console.log(\"START WALKING\");\n            const algorithm = this.getSelectedAlgorithmFunction();\n            if (algorithm === null) {\n                alert(\"Coming Soon !!!\");\n                return;\n            }\n            this.startLoading();\n            resetSourceAndTarget();\n            this.clearPath();\n            const { visitedNodes, path } = algorithm(\n                this.state.rows,\n                this.state.columns,\n                this.state.source,\n                this.state.target,\n                this.state.walls\n            );\n            // this.stopLoading();\n            // return;\n            for (let i = 0; i < visitedNodes.length; i++) {\n                setTimeout(() => {\n                    const nodeDom = document.querySelector(\n                        `#node-${visitedNodes[i].x}-${visitedNodes[i].y}`\n                    );\n                    if (nodeDom.classList.contains(\"node-unvisited\")) {\n                        nodeDom.classList.remove(\"node-unvisited\");\n                        nodeDom.classList.add(\"node-visited\");\n                    }\n                    if (i === visitedNodes.length - 1)\n                        setTimeout(() => {\n                            if (\n                                visitedNodes[i].x === this.state.target.x &&\n                                visitedNodes[i].y === this.state.target.y\n                            ) {\n                                document\n                                    .querySelector(\".node.node-source\")\n                                    .classList.add(\n                                        `path-to-${this.putNodeInPath(\n                                            path[0],\n                                            this.state.source\n                                        )}`\n                                    );\n                                for (let k = 0; k < path.length; k++) {\n                                    setTimeout(() => {\n                                        const node = path[k];\n                                        const nodeDom = document.querySelector(\n                                            `#node-${node.x}-${node.y}`\n                                        );\n                                        nodeDom.classList.remove(\n                                            \"node-visited\"\n                                        );\n                                        nodeDom.classList.add(\"node-path\");\n                                        if (k === path.length - 1) {\n                                            document\n                                                .querySelector(\n                                                    \".node.node-target\"\n                                                )\n                                                .classList.add(\n                                                    `path-to-${this.putNodeInPath(\n                                                        path[path.length - 1],\n                                                        this.state.target\n                                                    )}`\n                                                );\n                                            this.stopLoading();\n                                        }\n                                    }, this.state.speed * k * 2);\n                                }\n                            } else {\n                                alert(\"Target NOT Reachable\");\n                                this.stopLoading();\n                            }\n                        }, this.state.speed + 500);\n                }, this.state.speed * i);\n            }\n        }, 500);\n    };\n\n    updateMaze = (walls, visitedNodes) => {\n        this.setState({ walls, visitedNodes });\n    };\n\n    render() {\n        return (\n            <React.Fragment>\n                <Loader loading={this.state.loading} />\n                <NavBar\n                    selectedAlgorithmId={this.state.selectedAlgorithmId}\n                    selectedSpeedId={this.state.selectedSpeedId}\n                    onAlgorithmChanged={this.setAlgorithmId}\n                    onSpeedChanged={this.setSpeedId}\n                    startWalking={this.startWalking}\n                    clearPath={this.clearPath}\n                    destructWalls={this.destructWalls}\n                    resetMesh={this.resetMesh}\n                    rows={this.state.rows}\n                    columns={this.state.columns}\n                    source={this.state.source}\n                    target={this.state.target}\n                    speed={this.state.speed}\n                    onMazeCreated={this.updateMaze}\n                    startLoading={this.startLoading}\n                    stopLoading={this.stopLoading}\n                />\n\n                <Grid\n                    rows={this.state.rows}\n                    columns={this.state.columns}\n                    source={this.state.source}\n                    target={this.state.target}\n                    walls={this.state.walls}\n                    visitedNodes={this.state.visitedNodes}\n                    setNodeAsSource={this.setNodeAsSource}\n                    setNodeAsTarget={this.setNodeAsTarget}\n                    toggleWall={this.toggleWall}\n                />\n                <Legend />\n                <Insights insights=\"Insights\" />\n                <Copyright />\n            </React.Fragment>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n    <React.Fragment>\n        <App />\n    </React.Fragment>,\n    document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}